# JavaScript

## Essentials
- <a href="#">Learn JavaScript for FREE!</a> <br>
- <a href="#">Visit this repo for ES6 Cheat Sheet</a>

## Advanced Concepts
### Scope
Scope is about variables and where you can access them in your program, scope in javascript are lexical meaning that the acessebility of variables is determined by where your variables are writen in your code. So depending on where your variables are written certain parts of your programm may or may not be able to acess them.

JavaScript is primarily function scoped, the most basic way to create a new scope is to write a function. When the function is called it creates a new execution context which has its own variable enviroment (variable scope).

Inner scopes have acess to outer scopes meaning variables, a function nested in another function has acess to the variables in its parent functions variables this is known as cope chain.

- Global variable - It lives in the global scope, any variable you declare in the global scope will be acessable anywhere in your programm. It is the first link to the scope chain, you can go up the scope chain but not down the scope chain.

- `var` - Variables declared with the `var` keyword  are funtion scoped. Once you declare a variable within a fucntion you can you that variable anywhere in that fucntion.

- `let && const` - The variable declared with `let` or `const` keyword are block scoped meaning that when it is declared initialy in an if statement or function that is nested they are accessable within that scope, trying to acess them outside of that scope is impossible (block). 

### Hoisting
Hoisting also has to do when and how you can acess variables in your programm more specificly it is how javascript handles the variables that you declare with javascript. Hoisting with `var` keyword and functions handle hoisting differently than `const` and `let` Variable and function declarations are hoisted and assignments are not hoisted.

For example this block of code is logically correct and it works. <br>
```
function issaFunc() {
    console.log(`I am a function`);
}

issaFunc();
```
This block of code is looks logically incorrect but it works just as the one above because of *Hoisting*<br>
```
issaFunc();

function issaFunc() {
    console.log(`I'm a function`);
}
```

This works because in javascript `var` keyword variables and `function` declarations are hoisted to the top of their scope, because of this we can access variables and functions before they are physically declared in our code. 

It is like the our variable and function declarations are lifted above their assignments this however is a very elementary understanding and wouldn't work in all interviews.

This is how it works, a function creates a new execution context. An execution context works in who phases the compile phase and the execution phase, the compile phase comes first and then the execution phase. During the compile phase the JavaScript engine is going to through your functions and create a space in memory for all of your function and variable declararions, when the compile phase completes the execution phase will begin and your code will actually be run. This is why you have acess to your variable and function declarations when your code is run, even if you try to acess them before they are declare the JavaScript has already stored them in memory for you.

Remember that only variable and function declarations and hoisted *NOT assignments*. For example the following code will not work.
```
function cantHoistMe() {
    console.log(hoistMe);
    var hoistMe = "Cannot be hoisted";
}

cantHoistMe(); //returns undefined
```
```
cannotBeHoisted();

var cannotBeHoisted = function() {
    console.log("Can never be hoisted!);
}

//gives you an error
```

### Event Delegation (Bubbling)
Event delegation is a strategy that we can use to  optimize the performance of our web apps when responding to user events.

For example if you have the unordered list like so:
```
<ul id="parent">
    <li class="child>One</li>
    <li class="child>One</li>
    <li class="child>One</li>
</ul>
```
And you want to do something when a user clicks a list item, normally you would grab the list items by className and then loop through them and attach an event listener or handler to each one. This viable and will work:
```
const children = Array.from(document.getElementByClassName('child'));

children.forEach(child => {
    child.addEventListener('click', () => console.log(child.innerHTML));
})

//each list item will log their innerHTML when clicked.
```

To achieve the same thing with event delegation you will simply add one event listener to the parent element and handle the event there. This is possible because we will get access to the the event object which tell us which element triggered the event. Make sure to set a conditional before execution to identify whether the element clicked is the right one.

```
const parent = document.getElementById('parent');

parent.addEventListener('click', event => {
    if (event.target.className == 'child') {
        console.log(event.tarfet.innerHTML);
    }
})
```
This is possible because of *Event Propagation or Event Bubbling* , in this example when we click the list item that event travels up to the unordered list element and triggers the event handler that is placed there. When a DOM element is clicked the event travels up to each level of the dom and triggers any handlers listening for that event (up to the document level);

## Prototypes
